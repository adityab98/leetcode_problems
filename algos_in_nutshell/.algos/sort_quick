***** quicksort *****
context: worstcase quadratic if partitioning generates empty and maxsize arrays. pivot choice strongly influences performance
forces:
consequences: random pivot algo provides avgcase perf that beats other algos.
analysis: ideally, subproblems are half. provides same benefits as median sort without perf hassle of finding median
variations: stack to store subtasks (elim recursion), choose pivot based on median of 3, if partition size < min use insertion sort, when processing subproblems push larger sub onto stack to work on smaller problem first. introsort: if depth exceeds log(n) then switch to heapsort.
best: O(nlogn)
avg: O(nlogn)
worst: O(n^2)
related: recursion, array, divide and conquer

sort (A)
	quick_sort(A, 0, n - 1)

quick_sort (A, left, right)
	if (left < right)
		p = partition (A, left, right)
		quick_sort(A, left, p - 1)
		quick_sort(A, p, right)

partition (A, left, right)
	p = pivot(A, left, right) 	//use any strat, leftmost, rightmost, mid, random
	store = left
	for i = left to right - 1
		if (A[i] <= A[right])
			swap (A[i], A[store++])
		swap (A[right], A[store])

10,80,30,90,40,50,70 store=0,i=0
10<70, swap 10 with 10
10,80,30,90,40,50,70 store=1,i=1
80>70, swap 80 with 70
10,70,30,90,40,50,80 store=1,i=2
30<80, swap 30 with 70
10,30,70,90,40,50,80 store=2,i=3
90>80, swap 70 and 80
10,30,80,90,40,50,70 store=2,i=4
40<70, swap 40 and 80
10,30,40,90,80,50,70 store=3,i=5
50<70, swap 50 with 90
10,30,40,50,80,90,70
