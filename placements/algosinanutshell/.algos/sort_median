***** median sort *****
context: need to efficiently select median. using partition we can recursively find the median. we partition the array into 2 everytime. as long as the value returned by partition is not n/2, then we haven't found the pivot.
forces: as it is tail recursive, a non recursive implementation is straightforward
consequences: does too much work. altho subproblems are optimal, the way to generate them is costly. best select pivotindex randomly instead of using median
analysis: guarantees recursive problems are nearly equal. gives decent avg case. BFPRT is a good selectkth (find median) algorithm that runs in linear time.
best: O(nlogn)
avg: O(nlogn)
worst: O(n^2)
related: array, recursion, divide and conquer

sort (A)
	median_sort(A, 0, n - 1)

median_sort(A, left, right)
	if (left < right)
		find median value A[me] in A[left, right]
		mid = (right + left) / 2
		swap (A[mid], A[me])
		for i = left to mid - 1
			if (A[i] > A[mid])
				find A[k] <= A[mid] where k > mid
				swap (A[i], A[k])
		median_sort(A, left, mid - 1)
		median_sort(A, mid + 1, right)
