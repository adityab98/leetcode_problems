***** binary search *****
context: works whether searching thru numbers or names. logarithmic number of probes is necessary in the worst case
forces: keys for the eles must admit a total ordering that allows you to test whether an ele is greater than or equal to another. if collection is static, eles can be placed in an array.
consequences: adds small complexity for large performance gains. for example, if ur using secondary storage, time to search is dominated by storage access costs.
analysis: divides the problem by half every time it executes the loop. the max number of times it can be cut is log(n).
variations: if you want to support search-or-insert: 2 variations. first involves dealing with dynamic data where you must tune the imeplementation to allow efficient insertions and deletions into the collection while maintaining acceptable search performance. array is not good for this. first option is to use hash-based search using collision chaining. second option is to use binary tree.
best: O(1)
avg: O(logn)
worst: O(logn)
related: array, divide and conquer

search (A, t)
	low = 0
	high = n - 1
	while (low <= high)
		mid = (low + high) / 2
		if (t = A[mid])
			return true
		else if (t < A[mid])
			high = mid - 1
		else low = mid + 1
	return false
