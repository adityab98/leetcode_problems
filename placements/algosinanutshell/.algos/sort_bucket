***** bucket sort *****
context: fastest when eles to be sorted can be uniformly partitioned using a fast hashing function
forces: if storage space not imp and eles admit to an immediate total ordering, buckersort can take advantage of this extra knowledge for impressive cost savings
analysis: each ele inserted into bucket based on hash function (takes linear time), we also know eles in bucket i are lesser than eles in bucket j, if i < j. insertion_sort used when val extracted from bucket and written back to A
best: O(n)
avg: O(n)
worst: O(n)
related: array, hash
use when: data must be uniformly distributed for a given range. n buckets are created. buckets must also be ordered, i.e, if i < j, then eles inserted into b[i] are lexicographically smaller than eles in b[j]
variations: in hash_sort, each bucket reflects a unque hash code value returned by the hash function used on each ele. instead of creating n buckets, it creates a suitably large number of buckets k into which the eles are partitioned. as k grows in size, the performance improves. hash(e) must return an int for each ele e such that hash(a[i]) <= hash (a[j]) if a[i] < a[j]. eg: hash(e) for string which adds the first 3 letters of the string and stores into the bucket resulting from their sum

sort (A)
	create n buckets B
	for i = 0 to n - 1
		k = hash(A[i])
		B[k].append(A[i])
	extract (B, A)

extract (B, A)
	idx = 0
	for i = 0 to n - 1
		insertion_sort (B)
		for m = 1 to len(B[i])
			A[idx++] = B[i][m]
