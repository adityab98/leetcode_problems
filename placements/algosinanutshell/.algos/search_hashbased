***** hash-based search *****
context: imagine we're making a spell-checker as user types for a word processor-define a function to compute key for a string (must produce as many diff values as possible but vals need not be unique).
forces: hash function is vimp. storage space must be large enough to hold all search keys with enough space for collision keys. 
consequences: exhibits consequences of design decisions made when selecting data structure to store the elements of the collection
analysis: computing the hash value - bound by hash function. accessing item in table indexed by hash value - constant time. finding specific item in presence of collisions -  worst case when all eles hash to the same bin
best: O(1)
avg: O(1)
worst: O(n)
related: array, hash
desc: n eles loaded into hash table with b bins. each ele can be mapped to a key.
variations: instead of placing into linked list all eles that hash to a slot, we can use open_addressing - which stores the colliding items directly in the hash table. to use open_addressing, we change hash function to take 2 args h(u,j)=i where i and j are integers in the range [0,b-1] in which b is the size of A. h(u,0)=i=originalhashfunction. if slot at A[i] is occupied, we calculate value of h(u,1). if thats occupied, we calculate h(u,2), etc.

load_table (size, C)
	A = new array of given size
	for i = 0 to n - 1
		h = hash(C[i])
		if (A[h] is empty)
			A[h] = new linked_list
		add C[i] to A[h]
		return A
	
search (A, t)
	h = hash (t)
	list = A[h]
	if (list is empty)
		return false
	if (t in list)
		return true
	return false
